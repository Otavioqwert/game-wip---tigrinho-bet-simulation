/**\n * üéØ MOMENTUM CALCULATOR\n * Uses tetrahedral and triangular numbers for exponential progression\n */\n\n/**\n * Calcula momentum usando a f√≥rmula de n√∫meros tetra√©dricos e triangulares\n * f(1): Soma de n n√∫meros triangulares (N√∫mero Tetra√©drico) √ó 10\n * f(2): O n-√©simo n√∫mero triangular multiplicado por 100\n * f(final): Soma dos dois resultados\n * \n * F√≥rmula:\n * f(1) = (n √ó (n+1) √ó (n+2)) / 6 √ó 10\n * f(2) = (n √ó (n+1)) / 2 √ó 100\n * f(final) = f(1) + f(2)\n * \n * @param n O n√≠vel de momentum\n * @returns Threshold de progresso necess√°rio para o pr√≥ximo n√≠vel\n */\nexport function calculateMomentumThreshold(n: number): number {\n  // f(1): N√∫mero Tetra√©drico = (n √ó (n+1) √ó (n+2)) / 6 √ó 10\n  const f1 = ((n * (n + 1) * (n + 2)) / 6) * 10;\n  \n  // f(2): N√∫mero Triangular = (n √ó (n+1)) / 2 √ó 100\n  const f2 = ((n * (n + 1)) / 2) * 100;\n  \n  // f(final): Soma dos resultados\n  const fFinal = f1 + f2;\n  \n  return Math.max(1, Math.round(fFinal)); // Garante m√≠nimo de 1\n}\n\n/**\n * Calcula o n√≠vel de momentum baseado no progresso acumulado\n * @param totalProgress Progresso acumulado desde o in√≠cio\n * @returns { level: n√∫mero do n√≠vel, remainingProgress: progresso at√© o pr√≥ximo n√≠vel }\n */\nexport function calculateMomentumLevel(totalProgress: number): { level: number; remainingProgress: number } {\n  let level = 0;\n  let accumulatedProgress = 0;\n  \n  // Encontra o n√≠vel correto iterando at√© o progress ser insuficiente\n  while (true) {\n    const nextThreshold = calculateMomentumThreshold(level + 1);\n    if (accumulatedProgress + nextThreshold > totalProgress) {\n      break;\n    }\n    accumulatedProgress += nextThreshold;\n    level++;\n  }\n  \n  const remainingProgress = totalProgress - accumulatedProgress;\n  return { level, remainingProgress };\n}\n\n/**\n * Calcula a quantidade total de progresso necess√°rio para alcan√ßar um n√≠vel espec√≠fico\n * @param targetLevel N√≠vel desejado\n * @returns Total de progresso necess√°rio desde o in√≠cio do jogo\n */\nexport function calculateTotalProgressForLevel(targetLevel: number): number {\n  let total = 0;\n  for (let i = 1; i <= targetLevel; i++) {\n    total += calculateMomentumThreshold(i);\n  }\n  return total;\n}\n\n/**\n * Simula exemplos de progress√£o de momentum para debug/visualiza√ß√£o\n */\nexport function getMomentumProgression(maxLevels: number = 10): Array<{ level: number; threshold: number; cumulativeProgress: number }> {\n  const progression = [];\n  let cumulative = 0;\n  \n  for (let i = 0; i <= maxLevels; i++) {\n    const threshold = calculateMomentumThreshold(i);\n    cumulative += threshold;\n    progression.push({\n      level: i,\n      threshold,\n      cumulativeProgress: cumulative\n    });\n  }\n  \n  return progression;\n}\n"